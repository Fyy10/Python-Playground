\documentclass[UTF8]{ctexart}

\usepackage{WeeklyReport}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm2e}
\usepackage{algorithmicx}

\usepackage{ctex}
\usepackage[final]{pdfpages}
\usepackage{listings}
\usepackage[nottoc]{tocbibind}
\usepackage{url}
\usepackage{bm}
\usepackage{ulem}

\title{理解UNIX编程原则\\\rightline{\large——《UNIX编程艺术》读书报告}}
\author{计算机科学与工程学院 2018081302004 傅阳烨}
\date{\today}
\bibliographystyle{unsrt}

\renewcommand{\abstractname}{\large 摘要\\}

\begin{document}
    \maketitle
    % \tableofcontents
    \begin{abstract}
        这篇文章是在看了《UNIX编程艺术》\cite{ArtofUNIX} 一书部分章节后，对书中所提到的一些编程原则的理解与思考。
        本文试图从模块原则、文本化原则、透明性原则和经济原则几个方面对UNIX操作系统和应用程序的设计方法进行分析，
        谈一谈自己对这些原则的理解，以求对UNIX以及类UNIX操作系统有更深入的认识。

        尽管书 \cite{ArtofUNIX} 中所讨论的 UNIX 操作系统并不包括现在常见的 Linux 等操作系统，但 Linux 操作系统的设计中确实处处体现了 UNIX 的编程原则，
        因此也把 Linux 系统纳入了这篇文章的讨论范围。UNIX 一系的操作系统具有长久的发展历史，
        尽管经历过历史上的几次重大变革，但还是经久不衰，并且保留着丰富且活跃的社区，
        足以说明 UNIX 开发者在编程原则上的设计是有远见并且值得学习的。

        另外，UNIX 的编程原则不仅仅适用于 UNIX 操作系统和应用程序本身，在其它各种规模的开发项目中都值得借鉴，
        因此这篇文章也提到了一些能够体现 UNIX 编程原则但不属于 UNIX 操作系统的项目，
        希望能以此提供一个更为广阔的视角去思考和理解UNIX编程原则。\\

        \par\textbf{关键词：} UNIX操作系统；程序开发
    \end{abstract}
    \section{UNIX简介}
        提起 UNIX，大家总会想到上个世纪那种体型庞大的计算系统，以及在屏幕上显示字符界面并用闪烁的光标提示用户输入命令的老式电脑。
        在我开始去学习了解这个系统之前，也曾抱着相似的想法，而现在，我可以说，UNIX 并不是上个世纪的历史遗产，它和当前人们熟知的 Windows 和 MacOS 一样具有蓬勃的生命力。

        实际上，现在搭配了 X Window 或其它形式 GUI 的 UNIX/Linux 系统，尽管用户界面的体验上还不及当前炙手可热的 Windows 和 MacOS，
        但还是可以满足基本的图形化操作，并且 X Window 也只不过是系统中的一个进程而已，跟 shell 以及普通的命令并没有多少区别，
        图形化本身也不是 UNIX 操作系统及其开发人员所追求的内容。

        更细致一点地讲，UNIX \cite{UNIXwiki}，是一种强大的多用户，多任务的分时操作系统。
        尽管其诞生的年代确实很早\footnote{1969年由Ken Thompson、Dennis Ritchie和Douglas McIlroy在AT\&T的贝尔实验室开发\cite{UNIXwiki}}，
        但即便到现在，UNIX 在服务器、工作站等领域仍然有广泛的使用，其中很大一部分原因在于其具有良好的（甚至是无法比拟的）稳定性，
        而这与 UNIX 操作系统的程序设计原则是分不开的。

        接下来，我将对 UNIX/Linux 操作系统中一些程序设计的原则谈谈我的看法和理解。
    \section{UNIX编程原则}
        在这一节中，将主要关注 UNIX 编程设计中的模块原则、文本化原则、透明性原则和经济原则。
        虽然说这些是原则，但在我看来更像是人们在长期的开发和探索中总结出来的经验，
        它们就像是思想家们总结出来的哲理，只不过是以另一种方式呈现出来。
    \subsection{模块原则：使用简洁的接口拼合简单的部件}
        模块原则希望开发者们将一个大任务分割成多个小任务去完成，并分别实现相关功能。
        每个小程序只做好一件事，程序的输出简洁而干净，不带有无关信息的干扰。
        在 \ref{sec:text} 中所讲述的文本化原则使得不同程序之间可以很方便地连接起来，用清晰的接口把若干简单的模块组合成一个复杂的软件，降低整体复杂度。

        在模块原则中，每个程序只实现各个模块内部的功能，
        当前项目中所需要的功能，也许只需要使用先前别人写好的模块 \footnote{俗称轮子} 就行了，
        当前所开发的一些小程序，又可以当作模块封装起来后发布，对外提供接口，以便自己或他人后续开发时使用。

        在模块设计的时候应当注重正交性，即不同模块之间不能相互影响，当这个模块出现 bug 时，另外的模块要能正常运行，
        这样可以使得多数问题局限于某个局部，对局部的改进不至于牵动全身。

        模块原则实际上在软件开发的很多地方都有体现，即便是像 C 语言这样跟 UNIX 同一时期的产物（C 语言也是 UNIX 的开发者写的），也提供了诸如子函数、多文件等方式让程序设计呈现模块化。
        而在现代，模块化则更受开发者们青睐，一个大型软件的实现，往往被分割成多个子程序或者模块，由不同的开发人员分别实现之后再拼接起来形成整个软件。
        在很多编程语言中（如 python）就提供了非常丰富的软件包/软件库，程序员在进行软件设计和实现时只需要调用软件包提供的程序接口，
        将各个模块拼接起来，就可以完成一个井然有序，各尽其职的大型软件。

        但需要注意的是，划分模块并不是越小越好，模块划分得过于细致，会导致组织起来更为困难。其中一个原因在于不同模块之间提供的接口很难统一，
        为了符合模块接口而写的代码可能比模块本身还要多，
        从而也更容易出现 bug，调试起来也更为困难，这就背离了程序设计模块化的初衷。
    \subsection{文本化原则：数据流尽量用文本表示}\label{sec:text}
        文本化的原则，是希望让各个程序的数据流尽可能用文本表示。一个遵循文本化原则的程序，
        其输入和输出都是按照规定格式的文本，与其它同样将文本作为数据流的程序之间能够非常方便地协作。
        二进制格式或者其它特殊格式的数据在没有编写额外对接程序的情况下，很难在不同程序之间传递，
        这样就造成程序之间难以沟通，开发者也就只好把所有功能全部捆绑到一个软件上，造成软件臃肿且容易出错。

        而对于类UNIX操作系统，在平时使用的时候就可以感受到，shell 中绝大多数命令所处理的都是文本形式的信息，输出的也基本上是文本数据，
        这固然与UNIX的诞生环境有关（没有图形界面，只能用命令行操作，输入输出都是字符的形式），但受益于此，
        用户可以通过重定向和管道等操作，让各个命令之间协调运行，将一个命令的输出直接作为下一个命令的输入而不需要额外修改，
        从而达到使用较小的程序完成复杂工作的效果。

        假设现在需要统计一个项目中源代码的行数，在 Windows 操作系统中，可能需要安装 cygwin 等软件来运行类 UNIX 的 shell，
        用 UNIX 的 shell 命令来完成 \footnote{当然也可以使用新版Windows自带的Power Shell，但其功能远不及类UNIX系统的shell强大}，
        而在 UNIX 系统中，只需要一行带管道操作的命令搭配 find 和 wc 就可以完成，非常省时省力，这也是文本化原则的优点之一。

        另外，在 Linux 操作系统中，用户的配置文件全部都以文本的形式保存，方便用户理解和设置，系统软件由于遵循文本化原则，可以直接对文本形式的配置文件进行相关操作。
        而在 Windows 操作系统中，则大量使用二进制文件作为配置文件，
        不但需要特殊的工具才能打开，而且不同二进制文件之间的格式也不互通，理解起来也不如文本那么直白，从而造成配置的过程非常艰难。
        并且当二进制文件的格式发生变化时，所使用的一整套工具也需要跟着修改，原先的格式则不再支持，不具有普适性。

        由此可以看出，文本化原则在UNIX的设计中是非常重要的，它不仅使得不同程序之间能更好通信，也方便人们理解程序所处理的数据。
    \subsection{透明性原则：程序的设计要可见}
        透明性原则，主要体现在程序开发者的程序设计要可见，便于其他开发者甚至其原开发者进行审查和调试。
        代码是给人看的，而不是给机器看的，程序员在开发的时候就应当保持注释的习惯，
        这样无论未来维护这份代码的是自己还是别人，都有着重要的作用。
        在程序开发中遵循透明性原则可以让各个开发者一眼就能看出软件是在做什么以及如何做的，
        可以很方便地监视和现实软件内部的状态，在设计之初就考虑到软件的调试选项。

        在UNIX/Linux等操作系统的社区\footnote{https://www.linux.org/}中，一个好的项目/软件，往往会提供丰富的技术文档、开发手册、程序接口说明、使用示例等技术支持，
        帮助开发者和用户去理解软件的使用方法和设计思想，以便于让后来的开发者们能轻松地在原有项目基础上进一步开发和拓展，保证软件开发的活力。
        透明性原则要求程序不但能展示正确性，还能把开发者解决问题的思维模型告诉后来者，使得新的开发者在进入社区以及接手开发时不会有太大的“痛苦”：
        面对前开发者所写过的代码，只需要花相对较短的时间去阅读文档和代码，就能弄清楚它的设计思路和实现方式。

        同时，透明性原则也提倡接口简洁，方便其它程序对其操作，这也是 UNIX 操作系统能通过几条基本命令完成复杂任务的原因之一。
    \subsection{经济原则：宁花机器一分钟，不花程序员一秒}
        UNIX设计中的经济原则是站在“如何最大程度地节省精力”的角度去考虑的。
        对于一些机械性、无技术含量的工作，应该交给机器去自动化完成，而不应该占用程序员的宝贵时间，
        程序员应该把时间花在程序结构、模块接口、算法的设计上（体现其经济的特性）。

        比如，当程序员需要给程序进行测试，一种做法是人工编一些测试数据，手动输入之后看结果，这种方法不仅效率底下，编数据也很花时间，
        更为合理且省力的做法则是编写一个测试程序，随机生成数据，运行的结果用最为朴素（简单且容易实现）的方法实现的程序去验证，这样在很短的时间内可以进行大量测试，
        也能很快发现被测试的程序是否出错以及错在哪组数据上。

        当然，比较极致的经济原则也会造成这个现象：宁可用一个小时的时间开发一个程序去完成十分钟能手工做完的工作，
        听起来不太不明智，但这个程序能在接下来的过程中反复使用，并且在开发的过程中掌握了更多的知识和技能，下一次开发相似的程序就会轻车熟路，
        长此以往的积累过后，十分钟的任务就可以通过一分钟的编程和一秒钟的运行来实现。

        更进一步的经济原则（过渡到生成原则），还可以让机器来帮程序员生成代码。在 UNIX 的实验课程中我们已经使用 autoconf、automake 等命令来帮助我们自动生成 Makefile 文件，
        而 Makefile 本身其实也是帮助程序员自动构建项目的一个手段。
        程序在一步步帮程序员从无趣的编码中解放出来，
        让程序员能够更加专注于软件的设计、算法的优化、用户界面的设计等更为高层次的任务，从而大大提升了软件开发的效率。

        人类在程序自动化方面的探索是永无止境的，最近有研究人员开始用人工智能 \cite{CharRNN} \cite{LinuxKernelCode} 去学习 linux 内核代码，以便让人工智能去自动生成linux内核\footnote{一些生成的内核代码可以在这里看到：https://cs.stanford.edu/people/karpathy/char-rnn/linux.txt}。
        尽管生成的代码还编译不通，并且用人工智能写代码听起来天方夜谭，但这也是程序员们让程序代替人的一种尝试。
        更为疯狂的是，连创作音乐都能够以编程的方式来完成\footnote{项目主页请看 https://sonic-pi.net/}，这可能有点扯远了，但这正是人们在程序自动化上的一种尝试，是 UNIX 编程的经济原则在其它领域上的一种体现。

        实际上，汇编器、编译器和解释器也是为了这个目的而存在的，早期的程序员们编写程序是以手工输入机器指令的方式完成的，这种编程方式不仅耗时巨大，容易出错，并且极难调试，
        耗费巨资花数年时间编写出来的程序可能根本运行不了或者出现大量错误，汇编器、编译器等程序应运而生，当年需要数年时间完成的程序，现在可能只需要几个月甚至几天就能完成，并且错误少且容易调试和维护，因为由机器生成的代码往往比人手工输入来的更为可靠。
    \section{总结}
        从前面可以看到，在各个编程原则中，总是或多或少地与其它原则有所联系，实际上
        在UNIX的编程原则中，各个原则之间并不是相互独立的，而是相互影响，相互渗透的。满足了简洁原则和透明性原则的程序往往具有更好的健壮性，
        遵守模块原则的程序往往能够更为简洁。从经济原则中可以引出生成原则，为了遵循经济原则，程序员编写程序去完成繁杂而机械性的工作，
        从而把更多的时间和精力留给了算法设计和优化。

        人们常说，要学会举一反三，UNIX的哲学不仅仅在UNIX的系统设计中有所体现，在很多开源项目（开源精神本身也是UNIX哲学的一部分）以及企业项目中都能看到。
        如果把编程当作一门艺术而不是工作去看待，程序员的工作并不是死板的复制粘贴代码，
        而是去让机器协调工作，帮助人们处理事务，程序的设计如同画作、诗歌、音乐的创作一样，都是艺术的一种表现形式，
        程序员编写代码，实际上是在创造一个计算机的世界，用机器的语言去描绘心中的诗情画意。

        UNIX 操作系统与其它的操作系统大有不同，在 Windows 或 macOS 中，
        用户经常被现有的软件或工具所束缚，而在 UNIX 哲学中，
        如果没有工具或者对工具不满意，那就创造工具。美国著名科学家 Donald Knuth 在撰写他的系列著作 \cite{knuth1997art} 时，
        就因为不满足原有的排版工具，而自己开发了一套文章排版系统 \TeX \footnote{本文排版使用的就是 \TeX 的扩展版本 \LaTeX：https://www.latex-project.org/}。
        由于 UNIX 操作系统中的程序往往会遵循模块化、文本化、透明性等原则，使得用户可以相对更轻松地编写自己的程序或脚本来完成特定的任务。

        总而言之，秉承上述优秀编程思想的 UNIX/Linux 开发群组，源源不断地吸引新的开发者加入，
        从而让 UNIX/Linux 社区更为活跃，为类 UNIX 系统的建设和软件开发添砖加瓦。
    \newpage
    \nocite{KISS}
    \nocite{afzal2007unix}
    \bibliography{ref}
\end{document}
